!pip install mediapipe opencv-python
!pip install pretty_midi

import pretty_midi
import matplotlib.pyplot as plt
import pandas as pd
import cv2
import mediapipe as mp
import numpy as np

"""Takes in MIDI file, returns a matrix (pianoroll) with T rows and 88 columns"""

def midi_to_pianoroll(midi_path, fps=30, sustain_blur_frames=1):
    pm = pretty_midi.PrettyMIDI(midi_path)
    T = int(np.ceil(pm.get_end_time() * fps))
    roll = np.zeros((T, 88), dtype=np.float32)

    # merge all non-drum piano-ish instruments
    notes = []
    for inst in pm.instruments:
        if inst.is_drum: continue
        notes.extend(inst.notes)

    for note in notes:
        s = max(0, int(np.floor(note.start * fps)))
        e = min(T, int(np.ceil(note.end * fps)))
        k = note.pitch - 21
        if 0 <= k < 88:
            roll[s:e, k] = max(roll[s:e, k].max() if e>s else 0, note.velocity/127.0)

    # light temporal blur to mimic pedal / human legato
    if sustain_blur_frames > 0:
        from scipy.ndimage import gaussian_filter1d
        roll = gaussian_filter1d(roll, sigma=sustain_blur_frames, axis=0, mode='nearest')
        roll = np.clip(roll, 0, 1)
    return pianoroll

"""Takes in matrix, converts it to Gaussian heatmaps (with blobs around pressed keys)

"""

import numpy as np
import matplotlib.pyplot as plt

def piano_roll_to_heatmap(piano_roll, sigma_t=1.0, sigma_k=2.5, note_names=None, times=None):
    """
    Converts a piano roll (NumPy array, shape [T, 88]) into a Gaussian heatmap.

    Args:
        piano_roll: np.ndarray of shape [T, 88] with values 0-1
        sigma_t: temporal Gaussian std
        sigma_k: pitch Gaussian std
        note_names: optional list of 88 note names for plotting
        times: optional array of time values for plotting
    Returns:
        heatmap: np.ndarray of shape [T, 88]
    """
    num_frames, num_keys = piano_roll.shape
    heatmap = np.zeros_like(piano_roll, dtype=np.float32)

    # Precompute coordinate grid once
    t_coords = np.arange(num_frames)
    k_coords = np.arange(num_keys)
    TT, KK = np.meshgrid(t_coords, k_coords, indexing="ij")

    for t in range(num_frames):
        for k in range(num_keys):
            if piano_roll[t, k] > 0:
                gaussian = np.exp(-((TT - t) ** 2 / (2 * sigma_t**2) +
                                    (KK - k) ** 2 / (2 * sigma_k**2)))
                gaussian *= piano_roll[t, k]
                heatmap = np.maximum(heatmap, gaussian)

    # --- Visualization ---
    plt.figure(figsize=(12, 6))

    plt.subplot(1, 2, 1)
    plt.imshow(piano_roll.T, aspect='auto', origin='lower', cmap='gray_r')
    plt.title("Original Piano Roll")
    plt.xlabel("Time (frames)")
    plt.ylabel("Pitch (88 keys)")
    if note_names is not None:
        plt.yticks(np.arange(num_keys), note_names)
    if times is not None:
        plt.xticks(np.arange(0, num_frames, max(1, num_frames//10)),
                   np.round(times[::max(1, num_frames//10)], 2))

    plt.subplot(1, 2, 2)
    plt.imshow(heatmap.T, aspect='auto', origin='lower', cmap='hot')
    plt.title("Gaussian Heatmap")
    plt.xlabel("Time (frames)")
    plt.ylabel("Pitch (88 keys)")
    if note_names is not None:
        plt.yticks(np.arange(num_keys), note_names)
    if times is not None:
        plt.xticks(np.arange(0, num_frames, max(1, num_frames//10)),
                   np.round(times[::max(1, num_frames//10)], 2))

    plt.tight_layout()
    plt.show()

    return heatmap

midi_path = "/content/[Midi] Erik Satie - Gymnopedie No. 1.mid"
contact_maps = midi_to_pianoroll(midi_path, fps=30)
T = contact_maps.shape[0]

'''# Run the full pipeline
pianoroll = midi_to_pianoroll('/content/Twinkle-Little-Star-Nr-1.mid', 30)
heatmap = piano_roll_to_heatmap(pianoroll)
'''

"""# MIDI → Hand Skeleton Heatmaps

Extracts normalized key coordinates per frame
"""

mp_hands = mp.solutions.hands
hands = mp_hands.Hands(
    static_image_mode=False,
    max_num_hands=2,
    min_detection_confidence=0.5,
    min_tracking_confidence=0.5
)

def extract_hand_keypoints(video_path):
    cap = cv2.VideoCapture(video_path)
    all_frames = []

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        # Convert BGR -> RGB
        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = hands.process(rgb)

        keypoints_frame = {"left": [], "right": []}

        if results.multi_hand_landmarks and results.multi_handedness:
            for hand_landmarks, handedness in zip(results.multi_hand_landmarks,
                                                  results.multi_handedness):
                label = handedness.classification[0].label.lower()  # "left" or "right"
                for lm in hand_landmarks.landmark:
                    keypoints_frame[label].append((lm.x, lm.y, 1.0))  # normalized [0,1]

        all_frames.append(keypoints_frame)

    cap.release()
    return all_frames

"""Function to add Gaussian"""

def keypoints_to_heatmap(keypoints, H, W, sigma=3.0):
    heat = np.zeros((H, W), dtype=np.float32)
    ys = np.arange(H)[:, None]
    xs = np.arange(W)[None, :]
    for (x_n, y_n, score) in keypoints:
        cx = x_n * (W - 1)
        cy = y_n * (H - 1)
        g = np.exp(-(((xs - cx)**2 + (ys - cy)**2) / (2 * sigma**2)))
        heat += score * g
    if heat.max() > 0:
        heat /= heat.max()
    return heat

"""Extracting/printing keypoints, adding Gaussian"""

frames = extract_hand_keypoints("piano_vid.mov")
H, W = 64, 256

handL_heatmaps = [keypoints_to_heatmap(f["left"], H, W) for f in frames]
handR_heatmaps = [keypoints_to_heatmap(f["right"], H, W) for f in frames]

handL_heatmaps = np.stack(handL_heatmaps, axis=0)
handR_heatmaps = np.stack(handR_heatmaps, axis=0)

print(handL_heatmaps.shape, handR_heatmaps.shape)

import numpy as np
import matplotlib.pyplot as plt

def generate_keyboard_template(H=64, W=256):
    template = np.zeros((H, W), dtype=np.float32)

    # Number of piano keys
    num_keys = 88
    key_width = W / num_keys

    # Approximate white keys positions
    # There are 52 white keys on a piano
    white_key_indices = [0, 2, 4, 5, 7, 9, 11]  # repeating pattern for octaves
    for i in range(num_keys):
        # Decide if key is white (simplified)
        if i % 12 in white_key_indices:
            start = int(i * key_width)
            end = int((i + 1) * key_width)
            template[:, start:end] = 1.0  # mark as white key

    return template

# Example usage
keyboard_template = generate_keyboard_template(H=64, W=256)

# Visualization
plt.imshow(keyboard_template, cmap='gray', origin='lower')
plt.title("Keyboard Template")
plt.xlabel("Keys")
plt.ylabel("Height")
plt.show()

"""Stacking control tensor"""

H, W = keyboard_template.shape
T_video = handL_heatmaps.shape[0]
T_midi = heatmap.shape[0]

contact_maps_resized = np.zeros((T_video, H, W), dtype=np.float32)
for i, idx in enumerate(np.linspace(0, T_midi - 1, T_video).astype(int)):
    frame_resized = cv2.resize(heatmap[idx], (W, H))  # resize to (W,H)
    contact_maps_resized[i] = frame_resized

handL_heatmaps = handL_heatmaps[:T_video]
handR_heatmaps = handR_heatmaps[:T_video]

handL_heatmaps = handL_heatmaps.reshape((T_video, H, W))
handR_heatmaps = handR_heatmaps.reshape((T_video, H, W))

keyboard_channel = np.repeat(keyboard_template[None, :, :], T_video, axis=0)

assert contact_maps_resized.shape == (T_video, H, W)
assert handL_heatmaps.shape == (T_video, H, W)
assert handR_heatmaps.shape == (T_video, H, W)
assert keyboard_channel.shape == (T_video, H, W)

control_tensor = np.stack([
    contact_maps_resized,
    handL_heatmaps,
    handR_heatmaps,
    keyboard_channel
], axis=-1)

print("Control tensor shape:", control_tensor.shape)

import matplotlib.pyplot as plt

# Pick a frame index
for i in range(0, 86, 5):
  frame_idx = i # change as needed

# Titles for the 4 channels
  titles = ["MIDI Contact Map", "Left Hand", "Right Hand", "Keyboard Template"]

  plt.figure(figsize=(12, 3))

  for c in range(control_tensor.shape[-1]):
      plt.subplot(1, 4, c+1)
      plt.imshow(control_tensor[frame_idx, :, :, c], cmap='hot', origin='lower')
      plt.title(titles[c])
      plt.axis('off')

  plt.tight_layout()
  plt.show()

def contactmap_to_roll88(cm, keybed_rows=10, tau=0.1, axis='height'):
    T,H,W = cm.shape
    cm = cm.astype(np.float32)
    fm = cm.max(axis=(1,2), keepdims=True)
    cm = cm / (fm + 1e-8)

    if axis == 'width':
        keybed = cm[:, max(0,H-keybed_rows):, :]    # bottom rows
        row = keybed.max(axis=1)                   # [T,W]
    else:  # axis == 'height'
        keybed = cm[:, :, max(0,W-keybed_rows):]   # rightmost columns
        row = keybed.max(axis=2)                   # [T,H]

    L = row.shape[1]
    col2key = np.round(np.linspace(0,87,L)).astype(int)
    roll = np.zeros((T,88), np.float32)
    for k in range(88):
        cols = (col2key == k)
        if cols.any():
            roll[:,k] = row[:,cols].max(axis=1)

    return (roll >= tau).astype(np.uint8)

taus = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]
def eval_at_tau(tau):
    pr = contactmap_to_roll88(contact_maps_resized, keybed_rows=10, tau=tau, axis='height')
    # length align
    g = gt_roll
    if g.shape[0] != pr.shape[0]:
        idx = np.rint(np.linspace(0, g.shape[0]-1, pr.shape[0])).astype(int)
        g = g[idx]
    # ±1 frame tolerance
    def dilate_time(x, r=1):
        T,K = x.shape; y = x.copy()
        for d in range(1, r+1):
            y[:-d] |= x[d:]; y[d:] |= x[:-d]
        return y
    gd = dilate_time(g, 1); pd = dilate_time(pr, 1)
    TP = np.logical_and(pr==1, gd==1).sum()
    FP = np.logical_and(pr==1, gd==0).sum()
    FN = np.logical_and(g==1,  pd==0).sum()
    TN = np.logical_and(pr==0, gd==0).sum()
    acc  = (TP+TN)/(TP+TN+FP+FN+1e-8)
    prec = TP/(TP+FP+1e-8)
    rec  = TP/(TP+FN+1e-8)
    f1   = 2*prec*rec/(prec+rec+1e-8)
    return acc, prec, rec, f1, pr.mean()

for tau in taus:
    acc, prec, rec, f1, on = eval_at_tau(tau)
    print(f"tau={tau:.1f} | Acc {acc*100:5.2f}%  P {prec*100:5.2f}%  R {rec*100:5.2f}%  F1 {f1*100:5.2f}%  on-rate {on:.4f}")
